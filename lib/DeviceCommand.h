#ifndef DEVICECOMMAND_H
#define DEVICECOMMAND_H
#include <cstdint>
#include "CommandPayloadValue.h"
#include "SpecsEnums.h"

namespace THR
{
	/// <summary>
	/// Internal enum that contains all the available commands that SABR devices will recognize. Must track the const CMD ID definitions by a special relationship.
	/// </summary>
	enum class CommandType
	{
		// Note the value of each enum member must be the corresponding CMD ID value shifted right 4 times.
		/// <summary>
		/// This one isn't used; acts as a check that something wasn't initialized properly.
		/// </summary>
		Unknown = 0,
		InitDevice,
		CaptureEnable,
		LOFrequency,
		Gain,
		GainMode,
		Bandwidth,
		SampleRate,
		IRFilterCfg,
		TransmitEnable,
		DeviceStatus,
		MultiplexMode,
		Reset,
		ReferenceSource,
		IRFilterUse,
		AGCParams,
		CmdCounter = 0x000007F8,
		ChipsetID = 0x000007F9,
		FirmwareUpdate = 0x000007FA,
		Temperature = 0x000007FB,
		ERMVersion = 0x000007FC,
		/// <summary>
		/// Used for testing. What it does is variable.
		/// </summary>
		DebugB = 0x000007FD,
		/// <summary>
		/// Used for testing. What it does is variable.
		/// </summary>
		DebugA = 0x000007FE,
		/// <summary>
		/// Used for comms path testing; device will respond but will not do anything. 
		/// </summary>
		Nop = 0x000007FF
	};

	/// <summary>
	/// Helps define what specifically isn't valid about a DeviceCommand
	/// </summary>
	enum class DeviceResponseError
	{
		/// <summary>
		/// Everything OK
		/// </summary>
		None = 0,
		/// <summary>
		/// This means that the command ID is not found in the CommandType enum. Only comes from to-device frames.
		/// </summary>
		CommandNotRecognized,
		/// <summary>
		/// Checksum field of the from-device frame not valid.
		/// </summary>
		ChecksumFailure,
		/// <summary>
		/// Packet delimiters of the from-device frame not valid.
		/// </summary>
		FramingError,
		/// <summary>
		/// General device NACK from a from-device frame. Device should ACK during normal operation. NACK could mean unsupported command or invalid device state (can't do a certain action at a certain time).
		/// </summary>
		NotAcknowledged,
		/// <summary>
		/// Generated by the host when the device didn't produce a response to a command.
		/// </summary>
		DeviceNotResponding
	};

	/// <summary>
	/// An internal struct/class that handles the low level formation/decoding of SABR cmd frames. Not intended to be used directly by users.
	/// </summary>
	class DeviceCommand
	{
		/*
		 * RAW COMMAND PACKET STRUCTURE
		 * ===========================================================================
		 * |             HEADER              |        PAYLOAD          |   FOOTER    |
		 * |---------------------------------|-------------------------|-------------|
		 * |8b   1b     7b    1b   11b   4b  |    32b          32b     | 8b     24b  |
		 * |5A   A/N   RSVD   S/G  CMD   CH  | PAYLOAD_HI   PAYLOAD_LO | A5   CHKSUM |
		 * ===========================================================================
		 *                    |  CMD |
		 *                 32b               +          64b            +    32b
		 * Total: 128b (16 Byte)
		 * A/N is a device to host field
		 */
	private:
		//Header field definitions
		//                                              || (MARK)
		const uint32_t PACKET_PREFIX = 0x5A000000;
		const uint32_t PACKET_SUFFIX = 0xA5000000;
		const uint32_t DEV_ACK_RESP = 0x00800000;
		//                                                || (RSVD)
		const uint32_t SET_CMD_BIT = 0x00008000;
		const uint32_t GET_CMD_BIT = 0x00000000;
		// CMD IDs are 11 bit                               ||| (CMD)
		const uint32_t INIT_CMD_ID = 0x00000010;
		const uint32_t CAPTURE_IQ_CMD_ID = 0x00000020;
		const uint32_t LO_CMD_ID = 0x00000030;
		const uint32_t GAIN_CMD_ID = 0x00000040;
		const uint32_t GAINMODE_CMD_ID = 0x00000050;
		const uint32_t BANDWIDTH_CMD_ID = 0x00000060;
		const uint32_t SAMPLERATE_CMD_ID = 0x00000070;
		const uint32_t IR_FILTER_CFG_CMD_ID = 0x00000080;
		const uint32_t TRANSMIT_IQ_CMD_ID = 0x00000090;
		const uint32_t DEV_STAT_CMD_ID = 0x000000A0;
		const uint32_t MULTIPLEX_MODE_CMD_ID = 0x000000B0;
		const uint32_t RESET_CMD_ID = 0x000000C0;
		const uint32_t REFERENCE_SOURCE_CMD_ID = 0x000000D0;
		const uint32_t IR_FILTER_USE_CMD_ID = 0x000000E0;
		const uint32_t AGC_PARAMS_CMD_ID = 0x000000F0;
		const uint32_t CMD_COUNTER_CMD_ID = 0x00007F80;
		const uint32_t CHIPSET_CMD_ID = 0x00007F90;
		const uint32_t FIRMWARE_UPDATE_CMD_ID = 0x00007FA0;
		const uint32_t TEMPERATURE_CMD_ID = 0x00007FB0;
		const uint32_t ERM_VERSION_CMD_ID = 0x00007FC0;
		const uint32_t DEBUG_B_CMD_ID = 0x00007FD0;
		const uint32_t DEBUG_A_CMD_ID = 0x00007FE0;
		const uint32_t NOP_CMD_ID = 0x00007FF0;
		//                                                     | (CH)
		// Mask definitions
		const uint32_t PACKET_DELIMITER_MASK = 0xFF000000;
		const uint32_t ACK_NACK_FIELD_MASK = 0x00800000;
		const uint32_t SET_GET_CMD_FIELD_MASK = 0x00008000;
		const uint32_t CMD_ID_FIELD_MASK = 0x00007FF0;
		const uint32_t CMD_CHANNEL_FIELD_MASK = 0x0000000F;
		const uint32_t CHECKSUM_FIELD_MASK = 0x00FFFFFF;
		uint32_t header;
		CommandPayloadValue payloadValue;
		uint32_t footer;
		bool isValid;
		DeviceResponseError responseError;

		/// <summary>
		/// Used to verify that the raw frame from the SABR device is valid. Specifically checks for the frame prefix and suffix, the device ACK, and the checksum.
		/// </summary>
		/// <param name="header">The header field word</param>
		/// <param name="payloadValue">The payload word</param>
		/// <param name="footer">The footer field word (can be with or without an existing checksum field)</param>
		/// <param name="responseError">If the returned bool is false, this will tell you more about why it was false.</param>
		/// <returns>true if it is valid; false otherwise.</returns>
		bool IsRawPacketValid(uint32_t header, CommandPayloadValue payloadValue, uint32_t footer, DeviceResponseError& responseError);

		/// <summary>
		/// Note: Not currently implemented just returns a 0 for now!
		/// Calculates the checksum over the header, payload fields, and the non-checksum portion of the footer.
		/// </summary>
		/// <returns>The checksum field to be or'ed with the footer</returns>
		uint32_t CalculateChecksum(uint32_t header, CommandPayloadValue payloadValue, uint32_t footer);
	public:
		const uint32_t STD_RAW_PACKET_LENGTH_BYTES = 16;
		DeviceCommand();
		DeviceCommand(CommandType commandType, RadioChannel radioChannel, bool isSetCommand, CommandPayloadValue payloadValue);
		DeviceCommand(DeviceCommand& failedDeviceCommand);
		DeviceCommand(uint32_t header, CommandPayloadValue payloadValue, uint32_t footer);

		/// <summary>
		/// Determines if this command struct represents a valid and correct command frame. This technically checks different things depending on how the struct was made:
		/// For a to-device frame
		///     Checks if the command is a recognized one from the CommandType enum.
		/// For a from-device frame
		///     See IsRawPacketValid()
		/// </summary>
		/// <param name="responseError">If the returned bool is false, this will tell you more about why it was false.</param>
		/// <returns>true if it is trustworthy; false otherwise.</returns>
		bool IsValid(DeviceResponseError& responseError);

		/// <summary>
		/// Determines if this command struct represents a set or a get command.
		/// </summary>
		/// <returns>true if it is a set command; false for a get command.</returns>
		bool IsSetCommand();

		/// <summary>
		/// Gets the command type of this command struct.
		/// </summary>
		/// <returns>The type of command the struct represents.</returns>
		CommandType GetCommandType();

		/// <summary>
		/// Used to retrieve the payload value, typically for from-device frames as part of get commands.
		/// </summary>
		/// <returns>The payload value this struct contains.</returns>
		CommandPayloadValue GetPayloadValue();

		/// <summary>
		/// This is used to recreate a DeviceCommand struct from raw bytes (which comes from the device). Be sure to check IsValid() on the returned command before using it.
		/// </summary>
		/// <returns>The recovered command struct.</returns>
		uint8_t* ToSerializedBytes();
	};

	/// <summary>
	/// Used to generate an invalid response if the device timed out and never sent back an actual response.
	/// </summary>
	/// <param name="failedDeviceCommand">The original to device command that wasn't responded to.</param>
	/// <returns>An invalid response DeviceCommand.</returns>
	DeviceCommand* CreateInvalidResponse(DeviceCommand failedDeviceCommand);

	/// <summary>
	/// This serves as the true constructor for commands going to a SABR device. Should check IsValid() afterwards before sending on the command.
	/// </summary>
	/// <param name="commandType">The type of command this struct will represent</param>
	/// <param name="radioChannel">The channel the command will apply to. When in doubt, just use channel One.</param>
	/// <param name="isSetCommand">true if this is meant to be a set command; false for a get command.</param>
	/// <param name="payloadValue">A wrapper for containing the various numeric types that would be sent to the device represeting things like frequency, gain, etc.</param>
	/// <param name="radioCommand">The resulting command. Check the returned bool for its validity.</param>
	/// <returns>true if the commandType used was recognized; false if it was unrecognized.</returns>
	bool CreateCommand(CommandType commandType, RadioChannel radioChannel, bool isSetCommand, CommandPayloadValue payloadValue, DeviceCommand*& radioCommand);

	/// <summary>
	/// This is used to recreate a DeviceCommand struct from raw bytes (which comes from the device). Be sure to check IsValid() on the returned command before using it.
	/// </summary>
	/// <param name="serializedBytes">The command frame bytes sent from the device.</param>
	/// <returns>The recovered command struct.</returns>
	DeviceCommand* FromSerializedBytes(unsigned char* serializedBytes);
}

#endif